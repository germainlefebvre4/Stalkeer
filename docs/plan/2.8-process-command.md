# Task 2.8: Process Command Implementation

**Phase**: 2 (Core Functionality)  
**Complexity**: Large  
**Status**: Completed

## Overview

Implement the `process` command to parse M3U playlists, classify content, enrich with TMDB metadata, and store entries in the database. This command consolidates parsing, classification, filtering, and TMDB enrichment into a single integrated workflow.

### Success Criteria

- ✅ Parse M3U playlists and extract all metadata
- ✅ Classify content into movies, tvshows, channels, or uncategorized
- ✅ Match classified movies/tvshows with TMDB API to enrich metadata
- ✅ Store TMDB information (title, year, poster, overview, genres, TVDB ID, etc.) in related tables
- ✅ Store processed entries in the database with proper relationships
- ✅ Handle duplicates gracefully (based on line hash)
- ✅ Apply filters (include/exclude patterns) from config and runtime filters
- ✅ Track processing state and logs for audit trail
- ✅ Provide detailed statistics and progress feedback (including TMDB match rates)
- ✅ Complete processing of 10,000+ entries without errors

### Users and Usage

- CLI users processing M3U playlists locally
- Automated workflows processing playlists on schedule
- Development teams testing and validating M3U content

## Technical Approach

### Architecture

The `process` command orchestrates several existing components:

1. **Parser** (`internal/parser`): Read and parse M3U file line by line
2. **Classifier** (`internal/classifier`): Classify content type and extract metadata
3. **Filter** (`internal/filter`): Apply include/exclude patterns
4. **Matcher** (`internal/matcher`): Match content with TMDB API and enrich metadata
5. **Database** (`internal/database`): Store processed entries with GORM
6. **Logger** (`internal/logger`): Track progress and errors

### Data Flow

```
M3U File → Parser → Filter → Classifier → TMDB Matcher → Database
                                                            ↓
                                                    processed_lines table
                                                    movies/tvshows (with TMDB data)
                                                    channels/uncategorized tables
                                                    processing_logs table
```

### Key Components

**ProcessedLine Model** (already exists in `internal/models/playlist_item.go`):
- Stores M3U line metadata with hash-based deduplication
- Polymorphic relationships to movies, tvshows, channels, uncategorized
- Tracks processing state and download status

**Database Operations**:
- Use GORM transactions for batch inserts
- Check for existing line_hash before insert (skip duplicates)
- Create associated movie/tvshow/channel/uncategorized records
- Update processing_logs table with statistics

**Filtering Logic**:
- Load runtime filters from database (`filter_configs` table)
- Apply file-based filters from config if no runtime filters
- Skip entries that don't match include patterns or match exclude patterns

**TMDB Matching**:
- Match movies by title and year using TMDB Search API
- Match TV shows by title and extract episode details
- Configure language preference via Accept-Language header (e.g., "fr-FR,fr;q=0.9,en-US;q=0.5,en;q=0.5")
- Store enriched metadata: title, year, poster_path, backdrop_path, overview, genres, vote_average, popularity
- Handle match failures gracefully (store in uncategorized or with partial data)
- Respect TMDB API rate limits with circuit breaker and retry logic

### Major Technical Decisions

1. **Remove `parse` command**: Consolidate functionality into `process` with a `--no-db` flag for database-less validation (or users can use `dryrun` instead)
2. **Integrated TMDB matching**: Match and enrich metadata during processing rather than as separate step
3. **Configurable language**: Support Accept-Language header for TMDB API to retrieve metadata in preferred language
4. **Batch processing**: Process entries in batches (configurable, default 100) to improve performance
5. **Duplicate handling**: Skip entries with existing line_hash, optionally override with `--force` flag
6. **Transaction safety**: Use database transactions per batch to ensure consistency
7. **Progress reporting**: Show progress every N entries (configurable) for long-running operations
8. **TMDB rate limiting**: Use circuit breaker and retry logic to respect API limits

## Implementation Plan

### Phase 1: Core Processing Logic (Medium)

**Task 1.1: Create Processing Service** (Small)
- Create `internal/processor/processor.go` with `Processor` struct
- Initialize with dependencies: parser, classifier, filter, matcher, database
- Define `Process(filePath string, opts ProcessOptions)` method
- Define `ProcessOptions` struct: limit, force, batchSize, progressInterval, skipTMDB, tmdbLanguage
- Add unit test structure

**Task 1.2: Implement Entry Processing** (Medium)
- Parse M3U file using existing parser
- For each entry:
  - Check if line_hash exists in database (skip if found unless `--force`)
  - Apply filters (skip if doesn't match)
  - Classify content type using classifier
  - Extract season/episode/resolution metadata
  - Match with TMDB API (for movies/tvshows only)
  - Create ProcessedLine record with TMDB-enriched associations
- Return processing statistics (including TMDB match rates)

**Task 1.3: Database Integration** (Medium)
- Implement batch inserts with GORM transactions
- Create helper methods:
  - `saveProcessedLine(line *models.ProcessedLine) error`
  - `saveBatch(lines []*models.ProcessedLine) error`
  - `checkDuplicate(lineHash string) (bool, error)`
- Handle foreign key relationships (movie/tvshow/channel/uncategorized)
- Add error handling and rollback on failure

### Phase 2: TMDB Integration (Medium)

**Task 2.0: Integrate TMDB Matcher** (Medium)
- Wire up matcher service in processor
- Configure Accept-Language header for TMDB API requests (from config or CLI flag)
- For classified movies:
  - Call matcher.MatchMovie(title, year, language) to get TMDB data
  - Populate movie record with TMDB fields (tmdb_id, title, year, poster_path, overview, etc.)
  - Handle match failures (log warning, store with original data)
- For classified TV shows:
  - Call matcher.MatchTVShow(title, season, episode, language) to get TMDB data
  - Populate tvshow record with TMDB fields (tmdb_id, title, poster_path, overview, etc.)
  - Handle match failures (log warning, store with original data)
- Skip TMDB matching for channels and uncategorized content
- Add `--skip-tmdb` flag to disable TMDB matching
- Track TMDB match statistics (matched, not_found, errors)

**Task 2.1: Error Handling and Rate Limiting** (Small)
- Handle TMDB API errors gracefully (network errors, invalid responses)
- Use circuit breaker to prevent excessive failed requests
- Implement retry logic with exponential backoff
- Log TMDB API errors without failing entire processing
- Add fallback behavior when TMDB is unavailable

### Phase 3: Processing Logs and Statistics (Small)

**Task 3.1: Processing Log Tracking** (Small)
- Create processing_log entry at start (`in_progress` status)
- Update entry on completion with statistics
- Track: total_processed, duplicates_skipped, filtered_out, errors, tmdb_matched, tmdb_not_found
- Store error messages if processing fails
- Add timestamps: started_at, completed_at

**Task 3.2: Statistics and Reporting** (Small)
- Collect statistics during processing:
  - Total lines parsed
  - Successfully stored
  - Duplicates skipped
  - Filtered out
  - Classification breakdown (movies/tvshows/channels/uncategorized)
  - TMDB match rates (matched, not found, errors)
  - Processing duration
- Format and display statistics at completion
- Add verbose mode showing sample entries with TMDB data

### Phase 4: CLI Integration and Command Removal (Small)

**Task 4.1: Update `process` Command** (Small)
- Wire up processor service in `cmd/main.go`
- Implement command logic:
  - Load configuration (including TMDB API key and default language)
  - Initialize database
  - Create processor with dependencies (including matcher)
  - Call processor.Process() with options
  - Display statistics (including TMDB match rates)
- Add flags:
  - `--force`: Re-process existing entries
  - `--limit`: Maximum number of items to process
  - `--batch-size`: Batch size for database inserts (default: 100)
  - `--progress`: Show progress every N entries (default: 1000)
  - `--skip-tmdb`: Skip TMDB matching (faster, less enriched data)
  - `--tmdb-language`: Accept-Language header for TMDB (default: from config or "en-US")

**Task 4.2: Remove `parse` Command** (Small)
- Remove `parseCmd` from `cmd/main.go`
- Update help text and documentation
- Update completion notes in task 2.6
- Recommend using `dryrun` for validation without database

**Task 4.3: Update Documentation** (Small)
- Update README.md with `process` command usage
- Add examples for common workflows (with and without TMDB)
- Document flags and options
- Update DEVELOPMENT.md with processing workflow and TMDB integration

### Phase 5: Testing and Validation (Medium)

**Task 5.1: Unit Tests** (Medium)
- Test processor with mock dependencies (including mock matcher)
- Test batch processing logic
- Test duplicate detection
- Test filtering integration
- Test TMDB matching integration
- Test error handling and rollback
- Test statistics collection (including TMDB stats)

**Task 5.2: Integration Tests** (Medium)
- Test full processing workflow with real database and TMDB API
- Test with sample M3U files (100, 1000, 10000 entries)
- Verify database state after processing (including TMDB data)
- Test `--force` flag behavior
- Test `--limit` flag behavior
- Test `--skip-tmdb` flag behavior
- Test `--tmdb-language` flag with different languages (e.g., "fr-FR", "en-US")
- Test with various filter configurations
- Verify TMDB data is correctly stored in movies/tvshows tables
- Verify language-specific metadata is retrieved correctly

**Task 5.3: Performance Testing** (Small)
- Benchmark processing speed (entries per second with/without TMDB)
- Test memory usage with large files (100k+ entries)
- Verify batch processing improves performance
- Profile and optimize bottlenecks (especially TMDB API calls)
- Test TMDB rate limiting and circuit breaker behavior

## Considerations

### Assumptions

- Parser, classifier, filter, and matcher components are already implemented and tested
- Database schema includes all necessary tables and relationships (with TMDB fields)
- GORM is configured correctly for batch operations
- Filter system (file-based and runtime) is functional
- TMDB API key is available in configuration
- Matcher includes circuit breaker and retry logic for rate limiting
- Matcher supports Accept-Language header configuration for API requests

### Constraints

- Memory usage must be reasonable for large M3U files (streaming parser)
- Processing speed should handle 10,000+ entries in reasonable time (<10 minutes with TMDB)
- Database transactions should not lock tables for extended periods
- Progress reporting should not significantly impact performance
- TMDB API rate limits (40 requests per 10 seconds) must be respected
- TMDB matching adds latency to processing workflow

### Risks and Mitigation

**Risk 1: Memory exhaustion with large files**
- Mitigation: Use streaming parser, process in batches
- Fallback: Add configurable memory limits and batch size

**Risk 2: Database deadlocks during concurrent processing**
- Mitigation: Use appropriate transaction isolation levels
- Fallback: Implement retry logic with exponential backoff

**Risk 3: Partial processing failures**
- Mitigation: Use transactions per batch, track processing state
- Fallback: Add resume capability from last successful batch

**Risk 4: Performance degradation with filters**
- Mitigation: Optimize regex compilation, use efficient data structures
- Fallback: Add filter caching and precompilation

**Risk 5: TMDB API rate limiting or downtime**
- Mitigation: Use circuit breaker, retry logic, and respect rate limits
- Fallback: Add `--skip-tmdb` flag to continue without enrichment

**Risk 6: Poor TMDB match accuracy**
- Mitigation: Use normalized titles, year validation, fuzzy matching
- Fallback: Store partial data and allow manual correction later

## Not Included

The following features are out of scope for this task:

- Radarr/Sonarr integration (handled by Task 3.2)
- Download functionality (handled by Task 4.1)
- Web UI for processing management
- Real-time progress via WebSocket
- Scheduled/automated processing (future task)
- Multi-file processing in single command
- Parallel processing of multiple files
- Manual TMDB match correction interface
- TMDB caching layer (future optimization)

These features may be added in future iterations.

## Dependencies

- Task 2.1: M3U Parser (completed)
- Task 2.2: Content Classification (completed)
- Task 2.3: Filter System (completed)
- Task 2.7: TMDB Integration (completed)
- Task 1.3: Database Schema (completed)
- Task 2.6: CLI Structure (completed)

## Acceptance Criteria

## Acceptance Criteria

- [x] Process command successfully parses M3U files
- [x] Content is classified correctly (movies/tvshows/channels/uncategorized)
- [x] Movies/tvshows are matched with TMDB API
- [x] TMDB metadata is stored in movies/tvshows tables (tmdb_id, title, year, genres, duration, tvdb_id, etc.)
- [x] `--tmdb-language` flag allows configuring language for TMDB API
- [x] Language configuration also supported via config.yml
- [x] Entries are stored in database with proper relationships
- [x] Duplicates are detected and skipped based on line_hash
- [x] `--force` flag allows re-processing of existing entries
- [x] `--limit` flag restricts processing to N entries
- [x] `--skip-tmdb` flag disables TMDB matching
- [x] Filters (file-based and runtime) are applied correctly
- [x] TMDB API integrates retry logic and circuit breaker
- [x] Processing logs are created and updated with statistics (including TMDB match rates)
- [x] Statistics are displayed at completion (including TMDB success/failure rates)
- [x] Batch processing with configurable batch size
- [x] Progress reporting every N entries
- [ ] Unit tests achieve >80% code coverage for processor
- [ ] Integration tests pass with sample M3U files and TMDB API
- [ ] Documentation is updated with examples (with/without TMDB, different languages)

## Completion Notes

**Completed Components:**
- ✅ Full processor implementation in `/internal/processor/processor.go`
- ✅ Process command integrated in `/cmd/main.go`
- ✅ TMDB integration with automatic enrichment during processing
- ✅ Movie enrichment: `enrichMovie()` method
- ✅ TV show enrichment: `enrichTVShow()` method
- ✅ Title extraction and year parsing
- ✅ TV show title cleaning (removes season/episode markers)
- ✅ Batch processing with configurable batch size
- ✅ Progress reporting at configurable intervals
- ✅ Duplicate detection using line hash
- ✅ Filter integration (skip filtered items)
- ✅ ProcessingLog tracking with statistics
- ✅ TVDB ID retrieval via TMDB external IDs API
- ✅ Comprehensive error handling with stats tracking
- ✅ Statistics tracking: TMDBMatched, TMDBNotFound, TMDBErrors

**Configuration:**
```yaml
tmdb:
  enabled: true
  api_key: "your_api_key"
  language: "en-US"  # or "fr-FR,fr;q=0.9,en-US;q=0.5,en;q=0.5"
```

**CLI Flags:**
- `--force`: Re-process existing entries
- `--limit N`: Limit processing to N items
- `--batch-size N`: Batch size for database operations (default: 100)
- `--progress N`: Show progress every N items (default: 1000)
- `--skip-tmdb`: Skip TMDB matching
- `--tmdb-language`: Override language for TMDB API

**Statistics Output:**
- Total lines parsed
- Processed count
- Duplicates found
- Filtered out
- Movies count
- TV shows count
- Channels count
- Uncategorized count
- TMDB matched
- TMDB not found
- TMDB errors
- Processing duration

**Remaining Work:**
- ⏳ Comprehensive unit tests for processor
- ⏳ Integration tests with TMDB API
- ⏳ Performance testing with large datasets
- ⏳ Documentation updates with usage examples

## Implementation Notes

### Database Transaction Pattern

```go
// Batch processing with transaction
func (p *Processor) saveBatch(lines []*models.ProcessedLine) error {
    return database.Get().Transaction(func(tx *gorm.DB) error {
        for _, line := range lines {
            if err := tx.Create(line).Error; err != nil {
                return err
            }
        }
        return nil
    })
}
```

### Progress Reporting Pattern

```go
// Show progress every N entries
processed := 0
for i, entry := range entries {
    // Process entry
    processed++
    
    if processed % opts.ProgressInterval == 0 {
        log.Info(fmt.Sprintf("Processed %d/%d entries", processed, total))
    }
}
```

### Filter Integration Pattern

```go
// Apply filters before classification
if !filter.ShouldProcess(entry.GroupTitle, entry.TvgName) {
    stats.FilteredOut++
    continue
}
```

### TMDB Matching Pattern

```go
// Match with TMDB for movies/tvshows
if classified.Type == "movie" && !opts.SkipTMDB {
    // Configure language header (e.g., "fr-FR,fr;q=0.9,en-US;q=0.5,en;q=0.5")
    language := opts.TMDBLanguage
    if language == "" {
        language = "en-US" // fallback to English
    }
    
    tmdbData, err := matcher.MatchMovie(classified.Title, classified.Year, language)
    if err != nil {
        log.Warn("TMDB match failed", "title", classified.Title, "error", err)
        stats.TMDBNotFound++
    } else {
        // Populate movie record with TMDB data (in requested language)
        movie.TMDBId = tmdbData.ID
        movie.Title = tmdbData.Title
        movie.Year = tmdbData.Year
        movie.PosterPath = tmdbData.PosterPath
        movie.Overview = tmdbData.Overview
        // ... other fields
        stats.TMDBMatched++
    }
}
```
