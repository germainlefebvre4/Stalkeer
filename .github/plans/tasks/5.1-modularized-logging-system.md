# Task 5.1: Modularized Logging System

## Overview

### Problem Statement
Currently, Stalkeer uses a single logging configuration for both application and database logging. This creates limitations:
- Database query logs (from GORM) and application logs share the same log level
- Users cannot tune database logging verbosity independently from application logging
- No separation of concerns between infrastructure logging (database) and business logic logging (application)
- Debugging database issues requires enabling verbose logging for the entire application

### Success Criteria
- Separate log level configuration for application and database
- Users can configure log levels independently via `config.yml`
- Application logger and database logger can be instantiated separately
- Backward compatibility maintained (single log level still works with deprecation notice)
- No breaking changes to existing logging API
- All existing tests pass
- Clear migration path documented

### Users and Usage
- **Developers**: Debug database query performance without flooding application logs
- **Operators**: Tune production logging for optimal observability and performance
- **Support Teams**: Troubleshoot database issues with granular control

## Technical Approach

### Architecture Changes

**Current State:**
```
Config.Logging.Level → Application Logger
                     → Database Logger (GORM)
```

**Target State:**
```
Config.Logging.App.Level → Application Logger
Config.Logging.Database.Level → Database Logger (GORM)
Config.Logging.Level → [DEPRECATED] Fallback for both
```

### Key Components

1. **Enhanced Logger Package** (`internal/logger/logger.go`)
   - Keep existing `Logger` struct and methods unchanged
   - Add `NewWithLevel()` constructor for explicit level configuration
   - Add logger instance management (app and db loggers)
   - Maintain backward compatibility with `Default()` method

2. **Updated Configuration** (`internal/config/config.go`)
   - Extend `LoggingConfig` struct with nested app/database configs
   - Support both new and legacy configuration formats
   - Add validation and migration warnings

3. **Database Integration** (`internal/database/database.go`)
   - Use dedicated database log level from config
   - Map application log levels to GORM log levels appropriately

4. **Global Logger Management**
   - Introduce package-level functions to get app/db logger instances
   - Lazy initialization pattern
   - Thread-safe singleton access

### Data Models

**New Configuration Structure:**
```go
type LoggingConfig struct {
    // Legacy field (deprecated but supported)
    Level  string `mapstructure:"level"`
    Format string `mapstructure:"format"`
    
    // New modular configuration
    App      LogLevelConfig `mapstructure:"app"`
    Database LogLevelConfig `mapstructure:"database"`
}

type LogLevelConfig struct {
    Level string `mapstructure:"level"` // debug, info, warn, error
}
```

**Configuration Priority:**
1. If `logging.app.level` or `logging.database.level` are set, use them
2. Otherwise, fall back to `logging.level` (with deprecation warning)
3. Default to "info" if nothing is set

### Technical Decisions & Trade-offs

**Decision 1: Maintain Backward Compatibility**
- **Why**: Minimize disruption for existing deployments
- **Trade-off**: Slightly more complex config parsing logic
- **Mitigation**: Clear deprecation warnings and migration guide

**Decision 2: Use Package-Level Logger Functions**
- **Why**: Avoid dependency injection complexity across entire codebase
- **Trade-off**: Less testable (harder to mock)
- **Mitigation**: Provide test helpers for logger mocking

**Decision 3: Map Application Levels to GORM Levels**
- **Why**: GORM has different log level semantics (Silent/Error/Warn/Info)
- **Mapping**:
  - `debug` → GORM `Info` (shows all SQL queries)
  - `info` → GORM `Warn` (shows slow queries and errors)
  - `warn` → GORM `Warn` (shows warnings and errors)
  - `error` → GORM `Error` (shows errors only)
- **Trade-off**: Not perfect 1:1 mapping
- **Mitigation**: Document the mapping clearly

## Implementation Plan

### Phase 1: Foundation (Small - 2-3 hours)

**Task 1.1: Update Configuration Model** (Small)
- Extend `LoggingConfig` struct with `App` and `Database` nested structs
- Add `LogLevelConfig` type
- Maintain `Level` field for backward compatibility
- Add validation logic for log level values
- **Files**: `internal/config/config.go`
- **Dependencies**: None

**Task 1.2: Update Configuration Example** (Small)
- Update `config.yml.example` with new logging structure
- Add comments explaining app vs database logging
- Show both new and legacy formats
- **Files**: `config.yml.example`
- **Dependencies**: Task 1.1

**Task 1.3: Add Configuration Helper Methods** (Small)
- Add `GetAppLogLevel()` method to Config
- Add `GetDatabaseLogLevel()` method to Config
- Implement fallback logic (new config → legacy config → default)
- Add deprecation warnings when using legacy config
- **Files**: `internal/config/config.go`
- **Dependencies**: Task 1.1

### Phase 2: Logger Enhancement (Medium - 3-4 hours)

**Task 2.1: Add Logger Factory Methods** (Medium)
- Add `AppLogger()` package function returning app logger singleton
- Add `DatabaseLogger()` package function returning db logger singleton
- Implement lazy initialization with sync.Once
- Add `SetAppLogger()` and `SetDatabaseLogger()` for testing
- Keep existing `Default()` for backward compatibility
- **Files**: `internal/logger/logger.go`
- **Dependencies**: Task 1.3

**Task 2.2: Create GORM Logger Adapter** (Medium)
- Create new file `internal/logger/gorm_adapter.go`
- Implement GORM `logger.Interface` using application logger
- Map GORM log levels to application log levels
- Handle SQL query formatting and slow query warnings
- **Files**: `internal/logger/gorm_adapter.go` (new)
- **Dependencies**: Task 2.1

**Task 2.3: Update Database Initialization** (Small)
- Use `logger.DatabaseLogger()` instead of `logger.Default`
- Apply database log level from config helper
- Update log level mapping logic
- **Files**: `internal/database/database.go`
- **Dependencies**: Task 2.1, Task 2.2

### Phase 3: Application-Wide Integration (Medium - 2-3 hours)

**Task 3.1: Update Main Application** (Small)
- Replace `logger.Default()` with `logger.AppLogger()` in main.go
- Initialize loggers after config is loaded
- Add startup log messages showing configured levels
- **Files**: `cmd/main.go`
- **Dependencies**: Task 2.1

**Task 3.2: Update Service Loggers** (Medium)
- Update processor to use `logger.AppLogger()`
- Update parser to use `logger.AppLogger()`
- Update downloader to use `logger.AppLogger()`
- Update TMDB client to use `logger.AppLogger()`
- **Files**: Multiple service files
- **Dependencies**: Task 3.1

**Task 3.3: Update Cleanup Command** (Small)
- Replace `logger.Default()` with `logger.AppLogger()` in cleanup.go
- **Files**: `cmd/cleanup.go`
- **Dependencies**: Task 2.1

### Phase 4: Testing & Documentation (Medium - 3-4 hours)

**Task 4.1: Add Unit Tests** (Medium)
- Test config parsing with new structure
- Test config fallback logic (new → legacy → default)
- Test logger initialization
- Test GORM adapter
- Test concurrent logger access
- **Files**: `internal/config/config_test.go`, `internal/logger/logger_test.go`
- **Dependencies**: All Phase 2 tasks

**Task 4.2: Add Integration Tests** (Medium)
- Test application with app-level logging only
- Test application with database-level logging only
- Test application with both configured
- Test application with legacy config format
- Verify log output separation
- **Files**: New test file or existing test expansion
- **Dependencies**: All Phase 3 tasks

**Task 4.3: Update Documentation** (Small)
- Create migration guide for users
- Document new configuration options
- Add examples of common logging configurations
- Update STATUS.md or relevant docs
- **Files**: `docs/LOGGING.md` (new), `README.md`, `docs/DEVELOPMENT.md`
- **Dependencies**: None (can be done in parallel)

**Task 4.4: Add Deprecation Warnings** (Small)
- Log warning on startup if using legacy `logging.level`
- Include instructions to migrate
- Update to suggest new format
- **Files**: `internal/config/config.go`
- **Dependencies**: Task 1.3

### Phase 5: Testing & Validation (Small - 1-2 hours)

**Task 5.1: Manual Testing** (Small)
- Test with various log level combinations
- Verify database queries appear at correct levels
- Verify application logs appear at correct levels
- Test with legacy configuration
- Test configuration validation
- **Dependencies**: All previous phases

**Task 5.2: Performance Testing** (Small)
- Verify no performance regression
- Test logger initialization overhead
- Test concurrent logging performance
- **Dependencies**: Task 5.1

**Task 5.3: Update Existing Tests** (Small)
- Fix any tests broken by logger changes
- Update test helpers if needed
- Ensure all tests pass
- **Files**: Various test files
- **Dependencies**: All implementation tasks

## Considerations

### Assumptions
- Users are familiar with log levels (debug, info, warn, error)
- Current logging format (JSON) is sufficient
- GORM's log levels are acceptable for database logging
- No need for separate log output destinations (both go to same output)
- Users will update config files when upgrading

### Constraints
- Must maintain backward compatibility
- Cannot introduce breaking changes to logger API
- Must work with existing GORM integration
- Should not require code changes in most application files

### Risks

**Risk 1: Breaking Existing Deployments**
- **Likelihood**: Low (backward compatibility maintained)
- **Impact**: High
- **Mitigation**: Thorough testing, clear documentation, deprecation warnings

**Risk 2: Configuration Complexity**
- **Likelihood**: Medium
- **Impact**: Low
- **Mitigation**: Clear examples, sensible defaults, validation errors

**Risk 3: Incomplete Migration**
- **Likelihood**: Medium (many files use logger)
- **Impact**: Medium
- **Mitigation**: Use grep to find all logger.Default() calls, systematic replacement

**Risk 4: Testing Overhead**
- **Likelihood**: Low
- **Impact**: Medium
- **Mitigation**: Test helpers to mock loggers, focus on critical paths

## Not Included

The following features are out of scope for this task:

- **Separate Log Output Files**: App logs and database logs still go to same output
- **Structured Logging Fields**: No changes to log entry structure
- **Log Rotation**: File-based rotation remains external concern
- **Dynamic Log Level Changes**: No runtime API to change levels
- **Per-Package Log Levels**: No fine-grained control beyond app/database split
- **Custom Log Formatters**: JSON/text format remains as-is
- **Async Logging**: No background goroutines for log writing
- **Log Sampling**: No rate limiting or sampling of logs

These could be considered for future enhancements if needed.

## Example Configuration

### New Format (Recommended)
```yaml
logging:
  format: json
  app:
    level: info
  database:
    level: warn
```

### Legacy Format (Deprecated but Supported)
```yaml
logging:
  level: info
  format: json
```

### Mixed Format (Uses Specific + Fallback)
```yaml
logging:
  level: info  # Fallback for any unspecified
  format: json
  app:
    level: debug  # Override for app
  # database will use fallback 'info'
```

## Implementation Timeline

Total estimated effort: **11-16 hours** across 5 phases

- **Phase 1** (Foundation): 2-3 hours
- **Phase 2** (Logger Enhancement): 3-4 hours  
- **Phase 3** (Integration): 2-3 hours
- **Phase 4** (Testing & Docs): 3-4 hours
- **Phase 5** (Validation): 1-2 hours

Suggested approach: Implement phases sequentially, commit after each phase for incremental progress.

## Success Metrics

- [ ] All existing tests pass
- [ ] New configuration format works correctly
- [ ] Legacy configuration format still works with deprecation warning
- [ ] Application logs use app log level
- [ ] Database logs use database log level  
- [ ] Documentation updated
- [ ] Manual testing completed successfully
- [ ] No performance regression
- [ ] Code review completed
- [ ] Feature merged to main branch
