# Download Organization Implementation Plan

## Overview

Ensure that downloaded media files from Radarr and Sonarr are properly organized into configured directory structures that align with media server conventions. The system should download files to temporary locations and then move them to their final destinations in `config.downloads.movies_path` or `config.downloads.tvshows_path` with proper naming conventions.

### Success Criteria
- Files are downloaded to temporary directory first, then moved to final location
- Movie files follow structure: `{movies_path}/{Movie Title (Year)}/{Movie Title (Year)}.{ext}`
- TV show files follow structure: `{tvshows_path}/{Series Title}/Season {#}/{Series - S##E## - Episode}.{ext}`
- Atomic operations prevent partial/corrupted files in destination directories
- Failed downloads don't leave artifacts in destination directories
- File extensions are preserved from original stream URL
- Directory permissions are correctly set (0755 for directories, 0644 for files)

### Who Will Use This
System administrators running automated downloads from Radarr/Sonarr to populate media libraries.

## Technical Approach

### High-Level Architecture

1. **Download Phase**: 
   - Download to system temp directory or dedicated temp path
   - Track download progress and handle interruptions
   - Verify download completion

2. **Organization Phase**:
   - Determine correct destination path based on content type
   - Extract file extension from URL or content-type header
   - Create destination directory structure
   - Move file atomically to final location
   - Set proper file permissions

3. **State Management**:
   - Update `ProcessedLine.State` to "downloading" during download
   - Update to "organizing" during move operation
   - Update to "downloaded" when complete
   - Update to "failed" on any error with detailed error message

### Key Technology Choices

- **Temporary Storage**: Use OS temp directory (`os.TempDir()`) with unique subdirectory per download
- **File Extension Detection**: 
  1. Parse from URL path
  2. Fallback to Content-Type header mapping
  3. Default to `.mkv` for unknown types
- **Atomic Move**: Use `os.Rename()` when on same filesystem, otherwise copy + verify + delete
- **Path Sanitization**: Comprehensive character replacement for cross-platform compatibility

### Major Technical Decisions

**Decision 1: Temporary Download Location**
- **Options**: 
  - System temp dir
  - Configurable temp dir
  - Download directly to destination with `.tmp` suffix (current)
- **Choice**: System temp dir with fallback to configurable temp path
- **Rationale**: 
  - Prevents cluttering destination directories with failed downloads
  - Allows for downloads to different filesystem than destination
  - Better cleanup on crashes/restarts
  - Can leverage OS temp cleanup policies

**Decision 2: File Extension Handling**
- **Options**:
  - Always use `.mkv`
  - Detect from URL
  - Detect from Content-Type header
  - Use FFprobe to analyze file
- **Choice**: Multi-tier detection (URL → Content-Type → default)
- **Rationale**:
  - Most stream URLs have extensions in path
  - Content-Type provides fallback
  - FFprobe analysis too slow and resource-intensive
  - Default ensures files are always playable

**Decision 3: Cross-Filesystem Move Strategy**
- **Options**:
  - Always copy
  - Always rename
  - Try rename, fallback to copy
- **Choice**: Try rename, fallback to copy with verification
- **Rationale**:
  - Rename is instant and atomic when possible
  - Copy required when crossing filesystem boundaries
  - Verification prevents corruption
  - Delete source only after successful copy

## Implementation Plan

### Phase 1: Enhance Downloader (Day 1)

**Task 1.1: Temporary Directory Management** (Medium)
- Add `TempDir` field to `DownloadsConfig` (optional, defaults to OS temp)
- Create unique temp subdirectory per download: `stalkeer-download-{uuid}`
- Clean up temp directory on successful completion
- Background cleanup for orphaned temp directories on startup

**Task 1.2: File Extension Detection** (Small)
```go
// Add to downloader.go
func detectFileExtension(url string, contentType string) string {
    // 1. Try URL path
    if ext := filepath.Ext(url); ext != "" {
        return ext
    }
    
    // 2. Try Content-Type mapping
    extMap := map[string]string{
        "video/x-matroska": ".mkv",
        "video/mp4": ".mp4",
        "video/x-msvideo": ".avi",
        "video/quicktime": ".mov",
        // ... more mappings
    }
    if ext, ok := extMap[contentType]; ok {
        return ext
    }
    
    // 3. Default
    return ".mkv"
}
```
- Unit tests for various URL formats
- Unit tests for Content-Type mappings

**Task 1.3: Cross-Filesystem Move** (Medium)
```go
// Add to downloader.go
func moveFile(src, dst string) error {
    // Try rename first (fast, atomic)
    if err := os.Rename(src, dst); err == nil {
        return nil
    }
    
    // Fallback: copy + verify + delete
    if err := copyFile(src, dst); err != nil {
        return err
    }
    
    // Verify file sizes match
    srcInfo, _ := os.Stat(src)
    dstInfo, _ := os.Stat(dst)
    if srcInfo.Size() != dstInfo.Size() {
        os.Remove(dst)
        return errors.New("file size mismatch after copy")
    }
    
    // Remove source
    return os.Remove(src)
}
```
- Unit tests with mock filesystem
- Integration test with actual cross-filesystem scenario

**Task 1.4: Update Download Method** (Large)
Modify `Download()` method to:
1. Create temp directory
2. Download to temp file
3. Detect file extension
4. Update destination path with correct extension
5. Move file to final destination
6. Update state to "downloaded"
7. Clean up temp directory

### Phase 2: Update CLI Commands (Day 2)

**Task 2.1: Refactor Radarr Command** (Medium)
- Remove extension from destination path construction (will be added by downloader)
- Pass base destination path without extension
- Update progress reporting to show temp → final move
- Add error handling for organization failures

**Task 2.2: Refactor Sonarr Command** (Medium)  
- Remove extension from destination path construction
- Pass base destination path without extension
- Update progress reporting
- Add error handling for organization failures

**Task 2.3: Path Construction Utilities** (Small)
```go
// Add to cmd/main.go or new package
func buildMovieDestPath(basePath, title string, year int) string {
    dir := fmt.Sprintf("%s (%d)", sanitizeFilename(title), year)
    filename := dir // Without extension
    return filepath.Join(basePath, dir, filename)
}

func buildTVShowDestPath(basePath, seriesTitle string, season, episode int) string {
    dir := sanitizeFilename(seriesTitle)
    seasonDir := fmt.Sprintf("Season %02d", season)
    filename := fmt.Sprintf("%s - S%02dE%02d", sanitizeFilename(seriesTitle), season, episode)
    return filepath.Join(basePath, dir, seasonDir, filename)
}
```

### Phase 3: Error Handling & Recovery (Day 3)

**Task 3.1: Cleanup on Failure** (Medium)
- Remove temp files on download failure
- Don't create destination directories until ready to move
- Log failed downloads with full paths for debugging
- Add retry logic for organization phase separately from download phase

**Task 3.2: Startup Cleanup** (Small)
- On application startup, scan temp directory for orphaned downloads
- Log orphaned files
- Clean up files older than 24 hours
- Option to preserve for debugging (`--keep-temp` flag)

**Task 3.3: State Recovery** (Medium)
- Query database for items in "downloading" state on startup
- Mark as "failed" with reason "interrupted"
- Provide CLI command to retry failed downloads
- Unit tests for state recovery scenarios

### Phase 4: Testing & Documentation (Day 4)

**Task 4.1: Unit Tests** (Large)
- Downloader tests:
  - Extension detection from various URL formats
  - Content-Type header parsing
  - Cross-filesystem move scenarios
  - Temp directory cleanup
  - Permission setting
- Mocking:
  - HTTP responses with different Content-Type headers
  - Filesystem operations for cross-filesystem testing

**Task 4.2: Integration Tests** (Medium)
- End-to-end test: download → organize → verify
- Test with actual Radarr/Sonarr mock responses
- Test failure scenarios (network interruption, disk full, permission denied)
- Test cleanup on restart

**Task 4.3: Documentation** (Small)
- Update README with download organization details
- Document directory structure conventions
- Add troubleshooting section for download failures
- Update config.yml.example with temp_dir option

## Considerations

### Assumptions
- OS temp directory has sufficient space for downloads
- Destination directories are on writable filesystems
- File extensions can be reliably detected from URLs or Content-Type
- Radarr/Sonarr can import files from the organized structure

### Constraints
- Cross-filesystem moves are slower (full copy required)
- Temp directory space limited by OS configuration
- Large files may fill temp partition
- Concurrent downloads compete for disk I/O

### Risks and Mitigation

| Risk | Impact | Mitigation |
|------|--------|-----------|
| Temp directory full | High | Check available space before download; configurable temp dir |
| Partial files in destination | Medium | Always use temp + atomic move pattern |
| Extension detection failure | Low | Default to .mkv; log when defaulting |
| Cross-filesystem copy slow | Medium | Detect same filesystem; warn user if different |
| Orphaned temp files | Low | Automatic cleanup on startup; manual cleanup command |
| Permission errors | Medium | Check/set permissions explicitly; clear error messages |

## Dependencies

- Existing downloader implementation (`/internal/downloader/downloader.go`)
- Radarr/Sonarr CLI commands (`cmd/main.go`)
- Configuration system (`/internal/config/config.go`)

## Acceptance Criteria

### Must Have
- [x] Files download to temp directory first
- [x] Files moved to correct destination path after successful download
- [x] Movie structure: `{movies_path}/{Title (Year)}/{Title (Year)}.{ext}`
- [x] TV show structure: `{tvshows_path}/{Series}/Season ##/{Series - S##E##}.{ext}`
- [x] File extensions correctly detected and applied
- [x] Atomic move operations (rename or copy+verify+delete)
- [x] Failed downloads don't pollute destination directories
- [x] Temp directory cleaned up on success
- [x] State properly tracked in database
- [x] Unit tests for new functionality
- [x] Integration tests for full workflow

### Nice to Have
- [ ] Configurable temp directory path
- [ ] Parallel download support with queue management
- [ ] Bandwidth throttling
- [ ] Resume interrupted downloads
- [ ] Post-download verification (checksum, playability test)
- [ ] Automatic import to Radarr/Sonarr after download
- [ ] Email/webhook notifications on completion
- [ ] Download queue with prioritization

## Not Included

- Transcoding or format conversion
- Subtitle downloading
- NFO file generation
- Duplicate detection across sources
- Automatic quality selection
- Post-processing scripts
- Direct streaming without download

## Current State Analysis

After reviewing the existing code, the current implementation:

✅ **Already Implemented**:
- Downloads to temp files (`.tmp` suffix in same directory)
- Atomic rename from temp to final
- State tracking in database
- Directory creation
- Error handling with state updates

❌ **Needs Implementation**:
- Temp files created in destination directory (should use separate temp location)
- File extension detection (currently hardcoded in CLI)
- Cross-filesystem move handling
- Startup cleanup of orphaned downloads
- Explicit file extension in destination path construction

## Implementation Details

### Configuration Changes

Add to `config.yml`:
```yaml
downloads:
  movies_path: ./data/downloads/movies
  tvshows_path: ./data/downloads/tvshows
  temp_dir: ""  # Empty = use OS temp, or specify custom path
  max_parallel: 3
  timeout: 300
  retry_attempts: 3
  cleanup_temp_on_startup: true
  temp_retention_hours: 24
```

### Database Schema

No changes required. Use existing:
- `ProcessedLine.State`: downloading → organizing → downloaded/failed
- `ProcessedLine.DownloadInfoID`: Link to error details

### API Changes

**Downloader.Download()**
```go
type DownloadOptions struct {
    URL             string
    BaseDestPath    string  // Path without extension
    ProcessedLineID uint
    OnProgress      func(downloaded, total int64)
    Timeout         time.Duration
    RetryAttempts   int
}

type DownloadResult struct {
    FilePath      string  // Final path with extension
    TempPath      string  // Temp path used (for debugging)
    FileSize      int64
    Extension     string
    Duration      time.Duration
    BytesRead     int64
    MoveDuration  time.Duration
}
```

### Directory Structure Example

**Before (temp):**
```
/tmp/stalkeer-download-abc123/
  └── download.tmp
```

**After (final):**
```
./data/downloads/movies/
  └── The Matrix (1999)/
      └── The Matrix (1999).mkv

./data/downloads/tvshows/
  └── Breaking Bad/
      └── Season 01/
          └── Breaking Bad - S01E01.mkv
```

## Testing Strategy

### Unit Tests
1. Extension detection:
   - URLs with extensions: `.mkv`, `.mp4`, `.avi`
   - URLs without extensions
   - Content-Type header mappings
   - Default fallback

2. Path construction:
   - Special characters in titles
   - Very long titles
   - Titles with years in them
   - Unicode characters

3. File operations:
   - Same filesystem rename
   - Cross-filesystem copy
   - Permission errors
   - Disk full scenarios

### Integration Tests
1. Full download workflow:
   - Mock HTTP server with test file
   - Verify temp file created
   - Verify final file moved
   - Verify temp cleaned up
   - Verify database state

2. Failure scenarios:
   - Network interruption during download
   - Disk full during download
   - Permission denied on destination
   - Verify rollback and cleanup

3. Startup cleanup:
   - Create orphaned temp files
   - Restart application
   - Verify cleanup occurred

## Future Enhancements

1. **Smart Temp Location**: Automatically use fastest available disk for temp
2. **Compression**: Optional on-the-fly compression for archival
3. **Deduplication**: Hard link or reflink for duplicate files
4. **Bandwidth Shaping**: QoS for downloads
5. **Cloud Upload**: Direct upload to S3/GCS after download
6. **Streaming Optimization**: Download in chunks while organizing

## Rollout Plan

1. **Week 1**: Implement Phase 1 (Downloader enhancements)
2. **Week 2**: Implement Phase 2 (CLI updates) + Phase 3 (Error handling)
3. **Week 3**: Implement Phase 4 (Testing & docs)
4. **Week 4**: Beta testing with real Radarr/Sonarr instances
5. **Week 5**: Production release with monitoring

## Success Metrics

- Zero partial files in destination directories
- 99%+ successful organization rate
- < 1% orphaned temp files
- Average move time < 1 second for same filesystem
- Clear error messages for all failure scenarios
