# Task 2.8: Process Command Implementation

**Phase**: 2 (Core Functionality)  
**Complexity**: Large  
**Status**: Not Started

## Overview

Implement the `process` command to parse M3U playlists, classify content, and store entries in the database. This command consolidates the parsing functionality from the `parse` command with database persistence and removes the duplication between `parse` and `process` commands.

### Success Criteria

- Parse M3U playlists and extract all metadata
- Classify content into movies, tvshows, channels, or uncategorized
- Match classified movies/tvshows with TMDB API to enrich metadata
- Store TMDB information (title, year, poster, overview, genres, etc.) in related tables
- Store processed entries in the database with proper relationships
- Handle duplicates gracefully (based on line hash)
- Apply filters (include/exclude patterns) from config and runtime filters
- Track processing state and logs for audit trail
- Provide detailed statistics and progress feedback (including TMDB match rates)
- Complete processing of 10,000+ entries without errors

### Users and Usage

- CLI users processing M3U playlists locally
- Automated workflows processing playlists on schedule
- Development teams testing and validating M3U content

## Technical Approach

### Architecture

The `process` command orchestrates several existing components:

1. **Parser** (`internal/parser`): Read and parse M3U file line by line
2. **Classifier** (`internal/classifier`): Classify content type and extract metadata
3. **Filter** (`internal/filter`): Apply include/exclude patterns
4. **Matcher** (`internal/matcher`): Match content with TMDB API and enrich metadata
5. **Database** (`internal/database`): Store processed entries with GORM
6. **Logger** (`internal/logger`): Track progress and errors

### Data Flow

```
M3U File → Parser → Filter → Classifier → TMDB Matcher → Database
                                                            ↓
                                                    processed_lines table
                                                    movies/tvshows (with TMDB data)
                                                    channels/uncategorized tables
                                                    processing_logs table
```

### Key Components

**ProcessedLine Model** (already exists in `internal/models/playlist_item.go`):
- Stores M3U line metadata with hash-based deduplication
- Polymorphic relationships to movies, tvshows, channels, uncategorized
- Tracks processing state and download status

**Database Operations**:
- Use GORM transactions for batch inserts
- Check for existing line_hash before insert (skip duplicates)
- Create associated movie/tvshow/channel/uncategorized records
- Update processing_logs table with statistics

**Filtering Logic**:
- Load runtime filters from database (`filter_configs` table)
- Apply file-based filters from config if no runtime filters
- Skip entries that don't match include patterns or match exclude patterns

**TMDB Matching**:
- Match movies by title and year using TMDB Search API
- Match TV shows by title and extract episode details
- Configure language preference via Accept-Language header (e.g., "fr-FR,fr;q=0.9,en-US;q=0.5,en;q=0.5")
- Store enriched metadata: title, year, poster_path, backdrop_path, overview, genres, vote_average, popularity
- Handle match failures gracefully (store in uncategorized or with partial data)
- Respect TMDB API rate limits with circuit breaker and retry logic

### Major Technical Decisions

1. **Remove `parse` command**: Consolidate functionality into `process` with a `--no-db` flag for database-less validation (or users can use `dryrun` instead)
2. **Integrated TMDB matching**: Match and enrich metadata during processing rather than as separate step
3. **Configurable language**: Support Accept-Language header for TMDB API to retrieve metadata in preferred language
4. **Batch processing**: Process entries in batches (configurable, default 100) to improve performance
5. **Duplicate handling**: Skip entries with existing line_hash, optionally override with `--force` flag
6. **Transaction safety**: Use database transactions per batch to ensure consistency
7. **Progress reporting**: Show progress every N entries (configurable) for long-running operations
8. **TMDB rate limiting**: Use circuit breaker and retry logic to respect API limits

## Implementation Plan

### Phase 1: Core Processing Logic (Medium)

**Task 1.1: Create Processing Service** (Small)
- Create `internal/processor/processor.go` with `Processor` struct
- Initialize with dependencies: parser, classifier, filter, matcher, database
- Define `Process(filePath string, opts ProcessOptions)` method
- Define `ProcessOptions` struct: limit, force, batchSize, progressInterval, skipTMDB, tmdbLanguage
- Add unit test structure

**Task 1.2: Implement Entry Processing** (Medium)
- Parse M3U file using existing parser
- For each entry:
  - Check if line_hash exists in database (skip if found unless `--force`)
  - Apply filters (skip if doesn't match)
  - Classify content type using classifier
  - Extract season/episode/resolution metadata
  - Match with TMDB API (for movies/tvshows only)
  - Create ProcessedLine record with TMDB-enriched associations
- Return processing statistics (including TMDB match rates)

**Task 1.3: Database Integration** (Medium)
- Implement batch inserts with GORM transactions
- Create helper methods:
  - `saveProcessedLine(line *models.ProcessedLine) error`
  - `saveBatch(lines []*models.ProcessedLine) error`
  - `checkDuplicate(lineHash string) (bool, error)`
- Handle foreign key relationships (movie/tvshow/channel/uncategorized)
- Add error handling and rollback on failure

### Phase 2: TMDB Integration (Medium)

**Task 2.0: Integrate TMDB Matcher** (Medium)
- Wire up matcher service in processor
- Configure Accept-Language header for TMDB API requests (from config or CLI flag)
- For classified movies:
  - Call matcher.MatchMovie(title, year, language) to get TMDB data
  - Populate movie record with TMDB fields (tmdb_id, title, year, poster_path, overview, etc.)
  - Handle match failures (log warning, store with original data)
- For classified TV shows:
  - Call matcher.MatchTVShow(title, season, episode, language) to get TMDB data
  - Populate tvshow record with TMDB fields (tmdb_id, title, poster_path, overview, etc.)
  - Handle match failures (log warning, store with original data)
- Skip TMDB matching for channels and uncategorized content
- Add `--skip-tmdb` flag to disable TMDB matching
- Track TMDB match statistics (matched, not_found, errors)

**Task 2.1: Error Handling and Rate Limiting** (Small)
- Handle TMDB API errors gracefully (network errors, invalid responses)
- Use circuit breaker to prevent excessive failed requests
- Implement retry logic with exponential backoff
- Log TMDB API errors without failing entire processing
- Add fallback behavior when TMDB is unavailable

### Phase 3: Processing Logs and Statistics (Small)

**Task 3.1: Processing Log Tracking** (Small)
- Create processing_log entry at start (`in_progress` status)
- Update entry on completion with statistics
- Track: total_processed, duplicates_skipped, filtered_out, errors, tmdb_matched, tmdb_not_found
- Store error messages if processing fails
- Add timestamps: started_at, completed_at

**Task 3.2: Statistics and Reporting** (Small)
- Collect statistics during processing:
  - Total lines parsed
  - Successfully stored
  - Duplicates skipped
  - Filtered out
  - Classification breakdown (movies/tvshows/channels/uncategorized)
  - TMDB match rates (matched, not found, errors)
  - Processing duration
- Format and display statistics at completion
- Add verbose mode showing sample entries with TMDB data

### Phase 4: CLI Integration and Command Removal (Small)

**Task 4.1: Update `process` Command** (Small)
- Wire up processor service in `cmd/main.go`
- Implement command logic:
  - Load configuration (including TMDB API key and default language)
  - Initialize database
  - Create processor with dependencies (including matcher)
  - Call processor.Process() with options
  - Display statistics (including TMDB match rates)
- Add flags:
  - `--force`: Re-process existing entries
  - `--limit`: Maximum number of items to process
  - `--batch-size`: Batch size for database inserts (default: 100)
  - `--progress`: Show progress every N entries (default: 1000)
  - `--skip-tmdb`: Skip TMDB matching (faster, less enriched data)
  - `--tmdb-language`: Accept-Language header for TMDB (default: from config or "en-US")

**Task 4.2: Remove `parse` Command** (Small)
- Remove `parseCmd` from `cmd/main.go`
- Update help text and documentation
- Update completion notes in task 2.6
- Recommend using `dryrun` for validation without database

**Task 4.3: Update Documentation** (Small)
- Update README.md with `process` command usage
- Add examples for common workflows (with and without TMDB)
- Document flags and options
- Update DEVELOPMENT.md with processing workflow and TMDB integration

### Phase 5: Testing and Validation (Medium)

**Task 5.1: Unit Tests** (Medium)
- Test processor with mock dependencies (including mock matcher)
- Test batch processing logic
- Test duplicate detection
- Test filtering integration
- Test TMDB matching integration
- Test error handling and rollback
- Test statistics collection (including TMDB stats)

**Task 5.2: Integration Tests** (Medium)
- Test full processing workflow with real database and TMDB API
- Test with sample M3U files (100, 1000, 10000 entries)
- Verify database state after processing (including TMDB data)
- Test `--force` flag behavior
- Test `--limit` flag behavior
- Test `--skip-tmdb` flag behavior
- Test `--tmdb-language` flag with different languages (e.g., "fr-FR", "en-US")
- Test with various filter configurations
- Verify TMDB data is correctly stored in movies/tvshows tables
- Verify language-specific metadata is retrieved correctly

**Task 5.3: Performance Testing** (Small)
- Benchmark processing speed (entries per second with/without TMDB)
- Test memory usage with large files (100k+ entries)
- Verify batch processing improves performance
- Profile and optimize bottlenecks (especially TMDB API calls)
- Test TMDB rate limiting and circuit breaker behavior

## Considerations

### Assumptions

- Parser, classifier, filter, and matcher components are already implemented and tested
- Database schema includes all necessary tables and relationships (with TMDB fields)
- GORM is configured correctly for batch operations
- Filter system (file-based and runtime) is functional
- TMDB API key is available in configuration
- Matcher includes circuit breaker and retry logic for rate limiting
- Matcher supports Accept-Language header configuration for API requests

### Constraints

- Memory usage must be reasonable for large M3U files (streaming parser)
- Processing speed should handle 10,000+ entries in reasonable time (<10 minutes with TMDB)
- Database transactions should not lock tables for extended periods
- Progress reporting should not significantly impact performance
- TMDB API rate limits (40 requests per 10 seconds) must be respected
- TMDB matching adds latency to processing workflow

### Risks and Mitigation

**Risk 1: Memory exhaustion with large files**
- Mitigation: Use streaming parser, process in batches
- Fallback: Add configurable memory limits and batch size

**Risk 2: Database deadlocks during concurrent processing**
- Mitigation: Use appropriate transaction isolation levels
- Fallback: Implement retry logic with exponential backoff

**Risk 3: Partial processing failures**
- Mitigation: Use transactions per batch, track processing state
- Fallback: Add resume capability from last successful batch

**Risk 4: Performance degradation with filters**
- Mitigation: Optimize regex compilation, use efficient data structures
- Fallback: Add filter caching and precompilation

**Risk 5: TMDB API rate limiting or downtime**
- Mitigation: Use circuit breaker, retry logic, and respect rate limits
- Fallback: Add `--skip-tmdb` flag to continue without enrichment

**Risk 6: Poor TMDB match accuracy**
- Mitigation: Use normalized titles, year validation, fuzzy matching
- Fallback: Store partial data and allow manual correction later

## Not Included

The following features are out of scope for this task:

- Radarr/Sonarr integration (handled by Task 3.2)
- Download functionality (handled by Task 4.1)
- Web UI for processing management
- Real-time progress via WebSocket
- Scheduled/automated processing (future task)
- Multi-file processing in single command
- Parallel processing of multiple files
- Manual TMDB match correction interface
- TMDB caching layer (future optimization)

These features may be added in future iterations.

## Dependencies

- Task 2.1: M3U Parser (completed)
- Task 2.2: Content Classification (completed)
- Task 2.3: Filter System (completed)
- Task 2.7: TMDB Integration (completed)
- Task 1.3: Database Schema (completed)
- Task 2.6: CLI Structure (completed)

## Acceptance Criteria

- [ ] Process command successfully parses M3U files
- [ ] Content is classified correctly (movies/tvshows/channels/uncategorized)
- [ ] Movies/tvshows are matched with TMDB API
- [ ] TMDB metadata is stored in movies/tvshows tables (tmdb_id, title, year, poster, overview, genres, etc.)
- [ ] `--tmdb-language` flag allows configuring Accept-Language header for TMDB API
- [ ] Language-specific metadata (titles, overviews) is retrieved correctly
- [ ] Entries are stored in database with proper relationships
- [ ] Duplicates are detected and skipped based on line_hash
- [ ] `--force` flag allows re-processing of existing entries
- [ ] `--limit` flag restricts processing to N entries
- [ ] `--skip-tmdb` flag disables TMDB matching
- [ ] Filters (file-based and runtime) are applied correctly
- [ ] TMDB API rate limits are respected (circuit breaker, retry logic)
- [ ] Processing logs are created and updated with statistics (including TMDB match rates)
- [ ] Statistics are displayed at completion (including TMDB success/failure rates)
- [ ] `parse` command is removed from CLI
- [ ] Unit tests achieve >80% code coverage
- [ ] Integration tests pass with sample M3U files and TMDB API
- [ ] Performance: 10,000 entries processed in <10 minutes (with TMDB matching)
- [ ] Memory usage stays reasonable (<500MB for 100k entries)
- [ ] Documentation is updated with examples (with/without TMDB, different languages)

## Implementation Notes

### Database Transaction Pattern

```go
// Batch processing with transaction
func (p *Processor) saveBatch(lines []*models.ProcessedLine) error {
    return database.Get().Transaction(func(tx *gorm.DB) error {
        for _, line := range lines {
            if err := tx.Create(line).Error; err != nil {
                return err
            }
        }
        return nil
    })
}
```

### Progress Reporting Pattern

```go
// Show progress every N entries
processed := 0
for i, entry := range entries {
    // Process entry
    processed++
    
    if processed % opts.ProgressInterval == 0 {
        log.Info(fmt.Sprintf("Processed %d/%d entries", processed, total))
    }
}
```

### Filter Integration Pattern

```go
// Apply filters before classification
if !filter.ShouldProcess(entry.GroupTitle, entry.TvgName) {
    stats.FilteredOut++
    continue
}
```

### TMDB Matching Pattern

```go
// Match with TMDB for movies/tvshows
if classified.Type == "movie" && !opts.SkipTMDB {
    // Configure language header (e.g., "fr-FR,fr;q=0.9,en-US;q=0.5,en;q=0.5")
    language := opts.TMDBLanguage
    if language == "" {
        language = "en-US" // fallback to English
    }
    
    tmdbData, err := matcher.MatchMovie(classified.Title, classified.Year, language)
    if err != nil {
        log.Warn("TMDB match failed", "title", classified.Title, "error", err)
        stats.TMDBNotFound++
    } else {
        // Populate movie record with TMDB data (in requested language)
        movie.TMDBId = tmdbData.ID
        movie.Title = tmdbData.Title
        movie.Year = tmdbData.Year
        movie.PosterPath = tmdbData.PosterPath
        movie.Overview = tmdbData.Overview
        // ... other fields
        stats.TMDBMatched++
    }
}
```
